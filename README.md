# elvis-alexander.github.io





```
Frequency
	DONE_BUT_NOT_OPTIMAL - 301	Remove Invalid Parentheses	35.9%	Hard	
	DONE 273	Integer to English Words	22.8%	Hard	
	DONE 621	Task Scheduler	42.4%	Medium	
	DONE 283	Move Zeroes	51.7%	Easy	
	DONE 67	Add Binary	34.3%	Easy	
	DONE UNDER_IFFY 253	Meeting Rooms II	39.5%	Medium	
	DONE 325	Maximum Size Subarray Sum Equals k	43.1%	Medium	
	DONE 17	Letter Combinations of a Phone Number	36.7%	Medium	
	DONE 91	Decode Ways	20.4%	Medium	
	DONE 314	Binary Tree Vertical Order Traversal	38.0%	Medium	
	158	Read N Characters Given Read4 II - Call multiple times	24.6%	Hard	
	DONE 297	Serialize and Deserialize Binary Tree	35.3%	Hard	
	DONE 15	3Sum	21.8%	Medium	
	DONE 10	Regular Expression Matching	24.3%	Hard	
	311	Sparse Matrix Multiplication	52.6%	Medium	
	DONE 200	Number of Islands	36.8%	Medium	
	DONE 543	Diameter of Binary Tree	44.9%	Easy	
	278	First Bad Version	25.9%	Easy	
	689	Maximum Sum of 3 Non-Overlapping Subarrays	41.0%	Hard	
	277	Find the Celebrity	35.5%	Medium	
	76	Minimum Window Substring	27.0%	Hard	
	DONE 257	Binary Tree Paths	41.6%	Easy	
	DONE 73	Binary Search Tree Iterator	43.7%	Medium	
	DONE 121	Best Time to Buy and Sell Stock	43.1%	Easy	
	23	Merge k Sorted Lists	28.4%	Hard	
	636	Exclusive Time of Functions	44.6%	Medium	
	157	Read N Characters Given Read4	28.8%	Easy	
	125	Valid Palindrome	27.3%	Easy	
	680	Valid Palindrome II	32.2%	Easy	
	282	Expression Add Operators	30.7%	Hard	
	DONE 56	Merge Intervals	32.1%	Medium	
	DONE 211	Add and Search Word - Data structure design	25.6%	Medium	
	DONE 1	Two Sum	38.2%	Easy	
	DONE 252	Meeting Rooms	49.0%	Easy	
	341	Flatten Nested List Iterator	43.3%	Medium	
	DONE 597	Friend Requests I: Overall Acceptance Rate	37.8%	Easy	
	DONE 133	Clone Graph	25.2%	Medium	
	DONE 98	Validate Binary Search Tree	24.1%	Medium	
	DONE 43	Multiply Strings	28.1%	Medium	
	161	One Edit Distance	31.6%	Medium	
	DONE 78	Subsets	45.2%	Medium	
	DONE 215	Kth Largest Element in an Array	40.9%	Medium	
	139	Word Break	31.7%	Medium	
	DONE_BUT_NOT_OPTIMAL 721	Accounts Merge	33.2%	Medium	
	DONE 285	Inorder Successor in BST	35.2%	Medium	
	57	Insert Interval	29.1%	Hard	
	DONE 88	Merge Sorted Array	32.3%	Easy	
	602	Friend Requests II: Who Has the Most Friends	42.2%	Medium	
	238	Product of Array Except Self	50.4%	Medium	
	670	Maximum Swap	38.6%	Medium	
	DONE 785	Is Graph Bipartite?	38.6%	Medium	
	DONE 75	Sort Colors	39.1%	Medium	
	13	Roman to Integer	48.3%	Easy	
	DONE 33	Search in Rotated Sorted Array	31.9%	Medium	
	146	LRU Cache	20.1%	Hard	
	642	Design Search Autocomplete System	30.7%	Hard	
	DONE 206	Reverse Linked List	47.0%	Easy	
	523	Continuous Subarray Sum	23.4%	Medium	
	79	Word Search	28.2%	Medium	
	DONE 20	Valid Parentheses	34.1%	Easy	
	236	Lowest Common Ancestor of a Binary Tree	29.8%	Medium	
	DONE 49	Group Anagrams	38.9%	Medium	
	286	Walls and Gates	45.5%	Medium	
	494	Target Sum	43.8%	Medium	
	477	Total Hamming Distance	47.5%	Medium	
	38	Count and Say	36.9%	Easy	
	218	The Skyline Problem	29.2%	Hard	
	DONE 208	Implement Trie (Prefix Tree)	31.2%	Medium	
	102	Binary Tree Level Order Traversal	42.9%	Medium	
	209	Minimum Size Subarray Sum	32.3%	Medium	
	398	Random Pick Index	44.8%	Medium	
	380	Insert Delete GetRandom O(1)	40.0%	Medium	
	269	Alien Dictionary	26.5%	Hard	
	128	Longest Consecutive Sequence	38.4%	Hard	
	127	Word Ladder	20.2%	Medium	
	554	Brick Wall	46.5%	Medium	
	DONE 71	Simplify Path	26.4%	Medium	
	DONE_BUT_NOT_OPTIMAL 44	Wildcard Matching	21.1%	Hard	
	28	Implement strStr()	29.1%	Easy	
	DONE 	90	Subsets II	38.5%	Medium	
	647	Palindromic Substrings	54.7%	Medium	
	674	Longest Continuous Increasing Subsequence	42.5%	Easy	
	377	Combination Sum IV	42.8%	Medium	
	639	Decode Ways II	24.4%	Hard	
	334	Increasing Triplet Subsequence	39.8%	Medium	
	235	Lowest Common Ancestor of a Binary Search Tree	39.9%	Easy	
	69	Sqrt(x)	29.0%	Easy	
	117	Populating Next Right Pointers in Each Node II	33.9%	Medium	
	714	Best Time to Buy and Sell Stock with Transaction Fee	46.1%	Medium	
	461	Hamming Distance	69.5%	Easy	
	68	Text Justification	20.2%	Hard	
	50	Pow(x, n)	26.1%	Medium	
	85	Maximal Rectangle	29.8%	Hard	
	26	Remove Duplicates from Sorted Array	36.6%	Easy	
	410	Split Array Largest Sum	39.4%	Hard	
	DONE 210	Course Schedule II	30.4%	Medium	
	261	Graph Valid Tree	38.5%	Medium	
	274	H-Index	33.8%	Medium	
	221	Maximal Square	30.5%	Medium	
	234	Palindrome Linked List	33.6%	Easy	
	404	Sum of Left Leaves	47.6%	Easy	
	268	Missing Number	45.3%	Easy	
	25	Reverse Nodes in k-Group	31.9%	Hard	
	DONE - 80	Remove Duplicates from Sorted Array II	37.0%	Medium	
	168	Excel Sheet Column Title	27.4%	Easy	
	825	Friends Of Appropriate Ages	25.9%	Medium	
	673	Number of Longest Increasing Subsequence	31.7%	Medium	
	653	Two Sum IV - Input is a BST	50.0%	Easy	
	745	Prefix and Suffix Search	25.8%	Hard	
	DONE 637	Average of Levels in Binary Tree	56.0%	Easy	
	578	Get Highest Answer Rate Question	29.7%	Medium	
	750	Number Of Corner Rectangles	55.3%	Medium	
	DONE - 265	Paint House II	38.4%	Hard	
	764	Largest Plus Sign	37.9%	Medium	
	DONE 784	Letter Case Permutation	52.7%	Easy	
	275	H-Index II	34.9%	Medium	
	535	Encode and Decode TinyURL	73.8%	Medium	
	525	Contiguous Array	41.4%	Medium	
	801	Minimum Swaps To Make Sequences Increasing	26.4%	Medium	
	824	Goat Latin	56.7%	Easy	
	DONE 572	Subtree of Another Tree	40.2%	Easy	
	
	
    static class Edge {
        int weight;
        int v;
        Edge(int v) {
            this.v = v;
        }
    }

    static class Graph {
        LinkedList<Edge>[] adjList;
        Graph(int num_vertices) {
            adjList = new LinkedList[num_vertices];
            for(int i = 0; i < adjList.length; ++i)
                adjList[i] = new LinkedList<>();
        }
        void addEdge(int src, int dst) {
            adjList[src].add(new Edge(dst));
        }
        void bfs(int src) {
            Queue<Integer> queue = new LinkedList<>();
            Set<Integer> visited = new HashSet<>();
            queue.add(src);
            visited.add(src);
            while (! queue.isEmpty()) {
                int curr = queue.poll();
                System.out.print(curr + "," + "\t");
                for(Edge neighbor: adjList[curr]) {
                    if(! visited.contains(neighbor.v)) {
                        visited.add(neighbor.v);
                        queue.add(neighbor.v);
                    }
                }
            }
        }

        void dfs() {
            HashSet<Integer> visitedSet = new HashSet<>();
            for(int vertex = 0; vertex < adjList.length; ++vertex) {
                if(! visitedSet.contains(vertex)) {
                    dfsUtil(vertex, visitedSet);
                }
            }
        }

        private void dfsUtil(int vertex, HashSet<Integer> visitedSet) {
            visitedSet.add(vertex);
            System.out.print(vertex + "\t");
            for(Edge neighbor: adjList[vertex]) {
                if(! visitedSet.contains(neighbor.v))
                    dfsUtil(neighbor.v, visitedSet);
            }
        }

        private boolean isCyclic() {
            HashSet<Integer> visitedSet = new HashSet<>();
            HashSet<Integer> recursiveStack = new HashSet<>();
            for(int vertex = 0; vertex < adjList.length; ++vertex) {
                if(! visitedSet.contains(vertex)) {
                    if(isCyclicUtil(vertex, visitedSet, recursiveStack))
                        return true;
                }
            }
            return false;
        }

        private boolean isCyclicUtil(int vertex, HashSet<Integer> visitedSet, HashSet<Integer> recursiveStack) {
            visitedSet.add(vertex);
            recursiveStack.add(vertex);
            for(Edge neighbor: adjList[vertex]) {
                if(recursiveStack.contains(neighbor.v))
                    return true;
                if((! visitedSet.contains(neighbor.v)) && isCyclicUtil(neighbor.v, visitedSet, recursiveStack))
                    return true;
            }
            recursiveStack.remove(vertex);
            return false;
        }

        void topSort() {
            HashSet<Integer> visitedSet = new HashSet<>();
            Stack<Integer> stack = new Stack<>();
            for(int vertex = 0; vertex < adjList.length; ++vertex) {
                if(! visitedSet.contains(vertex)) {
                    topSort(vertex, visitedSet, stack);
                }
            }
            while (! stack.isEmpty())
                System.out.printf("%d\t", stack.pop());
        }

        private void topSort(int vertex, HashSet<Integer> visitedSet, Stack<Integer> stack) {
            visitedSet.add(vertex);
            for(Edge neighbor: adjList[vertex]) {
                if(! visitedSet.contains(neighbor.v))
                    topSort(neighbor.v, visitedSet, stack);
            }
            stack.push(vertex);
        }
    }

```
